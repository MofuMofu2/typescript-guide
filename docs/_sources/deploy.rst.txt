成果物のデプロイ
========================

TypeScriptで作ったアプリケーションの開発環境の作り方を、バリエーションごとに紹介してきました。それぞれの環境でビルド方法についても紹介しました。本章ではデプロイについて紹介します。

.. todo::

   npmパッケージ to npm
   npmパッケージ to nexus
   Dockerイメージ

   https://qiita.com/kannkyo/items/5195069c65350b60edd9

   https://qiita.com/shibukawa/items/fd49f98736045789ffc3#%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89%E5%91%A8%E3%82%8A%E3%81%AEdocker%E8%A8%AD%E5%AE%9A

npmパッケージとしてデプロイ
--------------------------------------

この方法でデプロイする対象は以下の通りです。

* Node.js用のライブラリ
* Node.js用のCLIツール
* Node.js用のウェブサービス

ビルドしたらアーカイブファイルを作ってみましょう。これで、package.tgzファイルができます。npm installにこのファイルのパスを渡すとインストールできます。アップロードする前に、サンプルのプロジェクトを作ってみて、このパッケージをインストールしてみて、必要なファイルが抜けていないか、必要な依存パッケージが足りているかといったことを確認してみましょう。また、展開してみて、余計なファイルが含まれていないことも確認すると良いでしょう。

.. code-block:: bash

   $ npm pack

* ビルドには必要だが、配布する必要のないファイルが含まれている

  ``.npmignore``\ ファイルにそのファイル名を列挙します。パッケージを作る時に無視されます。

* ビルドには必要だが、利用環境でインストール不要なパッケージがある

  ``package.json``\ の\ ``dependencies``\ から、\ ``devDependencies``\ に移動します。

npmのサイトにアップロードしてみましょう。

パッケージリポジトリはnpm以外にもあります。例えば、Nexusを使えばローカルにパッケージリポジトリが建てられます。GitHubもパッケージリポジトリを提供しています。

.. todo:: あとで書く

サーバーにアプリケーションをデプロイ
-------------------------------------------

Node.jsはシングルコアを効率よく使う処理系です。サーバーアプリケーションでマルチコアを効率よく使うには、プロセスマネージャを利用します。本書ではpm2を利用します。

* https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/

サンプルとしては次のコードを使います。

.. code-block:: ts
   :caption: src/main.ts

   import express, { Request, Response } from "express";
   import compression from "compression";
   import bodyParser from "body-parser";
   import gracefulShutdown from "http-graceful-shutdown";

   const app = express();
   app.use(compression());
   app.use(bodyParser.json());
   app.use(bodyParser.urlencoded({ extended: true }));

   app.get("/", (req: Request, res: Response) => {
       res.json({
           message: `hello ${req.headers["user-agent"]}`,
       });
   });

   const host = process.env.HOST || "0.0.0.0";
   const port = process.env.PORT || 3000;

   const server = app.listen(port, () => {
       console.log("Server is running at http://%s:%d", host, port);
       console.log("  Press CTRL-C to stop\n");
   });

   gracefulShutdown(server, {
       signals: "SIGINT SIGTERM",
       timeout: 30000,
       development: false,
       onShutdown: async (signal: string) => {
           console.log("... called signal: " + signal);
           console.log("... in cleanup");
           // shutdown DB or something
       },
       finally: () => {
           console.log("Server gracefulls shutted down.....");
       },
   });

``tsconfig.json``\ は\ ``npx tsc --init``\ で生成したものをひとまず使います。\ ``package.json``\ は以下のものを利用します。nccを使ってビルドする前提となっています。

.. code-block:: json
   :caption: package.json

   {
     "name": "webserver",
     "version": "1.0.0",
     "scripts": {
       "build": "ncc build src/main.ts",
     },
     "author": "Yoshiki Shibukawa",
     "license": "ISC",
     "dependencies": {
       "pm2": "^4.4.0"
     },
     "devDependencies": {
       "@types/body-parser": "^1.19.0",
       "@types/compression": "^1.7.0",
       "@types/express": "^4.17.7",
       "@zeit/ncc": "^0.22.3",
       "body-parser": "^1.19.0",
       "compression": "^1.7.4",
       "express": "^4.17.1",
       "http-graceful-shutdown": "^2.3.2",
       "typescript": "^3.9.7"
     }
   }

nccでビルドすると、\ dist/index.js``\ という一つの.jsファイルが生成されます。実行は\ ``node dist/index.js``\ の変わりに次のコマンドを利用します。これで、CPUコア数分Node.jsのインスタンスを起動し、クラスタで動作します。

.. code-block:: bash

   pm2 start dist/index.js -i max

pm2で起動すると、デーモン化されてアプリケーションが起動します。\ ``pm2 logs``\ コマンドでログをみたり、\ ``pm2 status``\ や\ ``pm2 list``\ で起動しているプロセスの状態を知ることができます。

デーモン化させないでフォアグラウンドで動作させる場合は\ ``--no-daemon``\ をつけて起動します。

Dockerイメージの作成
-------------------------------------------

この方法でデプロイする対象は以下の通りです。

* Node.js用のCLIツール
* Node.js用のウェブサービス
* ウェブフロントエンド

コンテナとは何か
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

コンテナは1アプリケーションだけが格納されたミニOS環境です。Linux上でもmacOS上でもWindows上でもクラウド環境でも、アプリケーションからは同じOS環境のように見えます。ポータブルなアプリケーション配布・実行環境としてますます地位が高まっています。コンテナは動いている環境のことを指します。コンテナは実行時にイメージを読み込んで環境を構築します。これは実行に必要なファイルと起動時のコマンドなどがセットになったものです。開発者が作るのはイメージです。

コンテナ関係のシステムは、実行のランタイムやビルド方法など、それぞれにいくつか選択肢がありますが、開発時の環境として一番ポピュラーなのがDockerです。本書ではコンテナ=Dockerコンテナとして説明をします。

ローカルではコンテナはDocker for Desktopを使ってイメージの作成や動作のテストができます。運用環境として、どのクラウド事業者もKubernetesを使ってコンテナベースで本番運用環境の維持管理できるサービスを提供しています。1つのノードにリソースが許すかぎり多数のコンテナを配置することができ、実行時の効率も上がります。
それ以外にも、AWS ECSやAWS Fargate、GCP Cloud Runなど、単体のDockerイメージやDockerイメージ群を起動できるサービスもあります。コンテナはウェブアプリケーションのような起動し続けるサービスにも使えますし、一度実行して終了するバッチ処理にも活用できます。

Dockerコンテナ内のアプリケーションは外部の環境と切り離されて実行されますが、Dockerの実行時のオプションで外界と接点を設定できます。複雑な設定が必要なアプリケーションの場合は、設定ファイルをコンテナ内の特定のパスに置くこともできますが、推奨されるのは環境変数のみによって制御されるアプリケーションです。

* 環境変数
* ネットワークの設定

  * 特定のポートをlocalhostに公開
  * localhostとコンテナ内部のを同一ネットワークにするかどうか

* ファイルやフォルダのマウント
* 最後に実行するコマンドのオプション

コンテナは上記のように、クラウドサービスに直接デプロイして実行できます。

複数のコンテナに必要な設定を与えてまとめて起動するツール（コンテナオーケストレーションツール）もあります。それがdocker-composeやKubernetesです。

Dockerのベースイメージの選択
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dockerイメージを作成するには\ ``Dockerfile``\ という設定ファイルを作成し、\ ``docker build``\ コマンドを使ってイメージを作成します。イメージは何もないところからゼロで作ることもできなくはないですが、基本的にはベースイメージと呼ばれる土台となるイメージを選択して、それに対して必要なファイルを追加します。ビルド済みのアプリケーションを単に置く、という構築方法もありますが（公式イメージの多くはそれに近いことをしている）、アプリケーション開発の場合はソースコードをDocker内部に送り、それをDocker内部でビルドして、実行用イメージを作成します。できあがったイメージをコンパクトにするために、ビルド用イメージと、実行用イメージを分ける（マルチステージビルド）が今の主流です。

Node.jsの公式のイメージは以下のサイトにあります。

* https://hub.docker.com/_/node/

バージョンと、OSの組み合わせだけイメージがあります。その中でおすすめの組み合わせが次の3つです。

.. list-table::
   :header-rows: 1
   :widths: 5 10 10 10 30

   - * 用途
     * バリエーション
     * ビルド用イメージ
     * 実行用イメージ
     * 解説
   - * Node.js(CLI/ウェブアプリ)
     * 鉄板
     * nodeのDebian系
     * nodeのDebian-slim系
     * ネイティブ拡張があっても利用可能
   - * Node.js(CLI/ウェブアプリ)
     * ネイティブ拡張なし
     * nodeのDebian-slim系
     * nodeのDebian-slim系
     * ビルド環境もコンパクトに
   - * Node.js(CLI/ウェブアプリ)
     * セキュリティ重視
     * nodeのDebian-slim系
     * distrolessのnode.js
     * コンテナへのログインを許さないセキュアな実行イメージ
   - * ウェブフロントエンド配信
     *
     * nodeのDebian-slim系
     * nginx:alpine
     *

.. todo:: Denoはこちらのスレッドを見守る https://github.com/denoland/deno/issues/3356

DebianはLinuxディストリビューションの名前です。buster (Debian 10)、stretch (Debian 9)、jessie (Debian 8)が執筆時点ではコンテナリポジトリにあります。それぞれ、無印がフル版で、gccや各種開発用ライブラリを含みます。いろいろ入っていて便利ですが、イメージサイズは大きめです。slimがつくバージョンがそれぞれにあります。これはNode.jsは入っているが、gccなどがないバージョンです。例えば、最新LTS（執筆時点で12）のDebianの開発環境込みのイメージであれば、\ ``node:12-buster``\ を選びます。

もう一つ、GCPのコンテナレジストリで提供されているのがdistrolessです。こちらはシェルもなく、セキュリティパッチも積極的に当てていくという、セキュリティにフォーカスしたDebianベースのイメージです。
シェルがないということはリモートログインができませんので、踏み台にされる心配がないイメージです。これはGCPのコンテナレジストリに登録されており、\ ``gcr.io/distroless/nodejs``\ という名前で利用可能です。

Alpineというサイズ重視のOSイメージはありますが、あとから追加インストールしなければならないパッケージが増えがちなのと、パッケージのバージョン固定がしにくい（古いパッケージが削除されてしまってインストールできなくなる）などの問題がありますし、他のイメージがだいたいDebianベースなので、Debianベースのもので揃えておいた方がトラブルは少ないでしょう。

Dockerイメージはサイズが重視されますが、ビルド時間や再ビルド時間も大切な要素です。開発ツールなしのイメージ（slimやalpineなど）を選び、必要な開発ツールだけをダウンロードするのはサイズの上では有利ですが、すでにできあがったイメージをただダウンロードするのよりも、依存関係を計算しながら各パッケージをダウンロードする方が時間がかかります。

CLI/ウェブアプリケーションのイメージ作成
-------------------------------------------------------------

CLIとウェブアプリケーションの場合の手順はあまり変わらないので一緒に説明します。ベースイメージの選択では3種類の組み合わせがありました。

* C拡張あり（Debian系でビルド）
* C拡張なし（Debian-slim系でビルド）
* セキュリティ重視（destrolessに配信）

前2つ目はベースイメージが\ ``node:12-buster``\ から\ ``node:12-buster-slim``\ に変わるだけですので、まとめて紹介します。

なお、Node.jsはシングルコアで動作する処理系ですので、マルチコアを生かしたい場合はインスタンスを複数起動し、ロードバランスをする仕組みを外部に起動する必要があります。

Debianベースのイメージ作成とDockerの基礎
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

まず、イメージにするアプリケーションを作成します。コンテナの中のアプリケーションは終了時にシグナルが呼ばれますので、シグナルに応答して終了するように実装する必要があります。


Dockerfileはコンテナのイメージを作成するためのレシピです。行志向のスクリプトになっています。

.. code-block:: docker
   :caption: Dockerfile

   # ここから下がビルド用イメージ

   FROM node:12-buster AS builder

   WORKDIR app
   COPY package.json package-lock.json ./
   RUN npm ci
   COPY tsconfig.json ./
   COPY src ./src
   RUN npm run build

   # ここから下が実行用イメージ

   FROM node:12-buster-slim AS runner
   WORKDIR /opt/app
   COPY --from=builder /app/dist ./
   USER node
   EXPOSE 3000
   CMD ["node", "/opt/app/index.js"]

``FROM``\ はベースとなるイメージを選択する命令です。ここではビルド用のベースイメージと、実行用のベースイメージと2箇所\ ``FROM``\ を使用しています。\ ``FROM``\ から次の\ ``FROM``\ 、あるいはファイルの終行までがイメージになります。ここでは2つイメージが作られていますが、最後のイメージが、このDockerfileの成果物のイメージとなります。

それぞれのイメージの中ではいくつかの命令を使ってイメージを完成させていきます。

``COPY\ は実行場所（コンテキスト）や別のイメージ（\ ``--from``\ が必要）からファイルを取得してきて、イメージ内部に配置する命令です。このサンプルでは使っていませんが、\ ``ADD``\ 命令もあり、こちらは\ ``COPY``\ の高性能バージョンです。ネットワーク越しにファイルを取得できますし、アーカイブファイルを展開してフォルダに配置もできます。\ ``RUN``\ は何かしらの命令を実行します。

あと重要なポイントが、このイメージ作成のステップ（行）ごとに内部的にはイメージが作成されている点です。このステップごとのファイルシステムの状態は「レイヤー」と呼ばれます。このレイヤーはキャッシュされて、ファイルシステムの状態に差分がなければキャッシュを利用します。イメージの内部にはこのレイヤーがすべて保存されています。例えば、ファイルを追加、そして削除をそれぞれ1ステップずつ実行すると、消したはずのファイルもレイヤーには残ってしまい、イメージサイズは大きなままとなります。

実行用イメージはこのレイヤーとサイズの問題は心の片隅に置いておく方が良いですが（優先度としては10番目ぐらいです）、ビルド用のイメージはサイズが大きくなっても弊害とかはないので、なるべくステップを分けてキャッシュされるようにすべきです。また、キャッシュ効率をあげるために、なるべく変更が少ない大物を先にインストールすることが大切です。

上記のサンプルではパッケージ情報ファイル（\ ``package.json``\ と\ ``package-lock.json``\ ）取得してきてサードパーティのライブラリのダウンロード（\ ``npm install``\ ）だけを先に実行しています。利用パッケージの変更はソースコードの変更よりもレアケースです。一方、ソースコードの変更は大量に行われます。そのためにソースコードのコピーを後に行っています。もし逆であれば、ソースコード変更のたびにパッケージのダウンロードが走り、キャッシュがほとんど有効になりません。このようにすれば、ソースコードを変更して再ビルドするときは\ ``COPY src``\ の行より以前はスキップされてそこから先だけが実行されます。

実行用イメージの最後は\ ``CMD``\ 命令を使います。いつものスクリプトの実行と同じように記述すれば問題ありません。

distrolessベースのDockerイメージの作成
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



ウェブフロントエンドのDockerイメージの作成
-----------------------------------------------------

シングルページアプリケーションをビルドすると静的なHTMLやJS、CSSのファイル群ができます。これらのファイルを利用する方法はいくつかあります。

* CDNにアップロードする
* オブジェクトストレージにアップする
* Dockerコンテナとしてデプロイする

このうち、CDNやオブジェクトストレージへのアップロードはそれぞれのサービスごとの作法に従って行ます。ここではDockerコンテナとしてデプロイする方法を紹介します。

.. todo:: 
