
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>基本的な型付け &#8212; 仕事ですぐに使えるTypeScript  ドキュメント</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="関数" href="function.html" />
    <link rel="prev" title="基本的な構文" href="syntax.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>基本的な型付け<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>TypeScriptはJavaScriptに対して型をつけるという方向で仕様が作られています。
JavaScriptは動的言語の中でも、いろいろ制約がゆるく、無名関数とオブジェクトを使ってかなり柔軟なプログラミングの手法を提供してきました。
そのため、オブジェクトに対して型をつける方法についても、他のJavaなどの静的型付け言語よりもかなり複雑な機能を持っています。</p>
<p>ただし、ここに説明されている機能を駆使して完璧な片づけを行う必要があるかというと、それは時と場合によります。
たとえば、TypeScriptを使ってライブラリを作る場合、それを利用するコードもTypeScriptであれば型チェックでコンパイル時にチェックが行われます。
しかし、利用する側がJavaScriptの場合は、型によるチェックができません。エラーを見逃すことがありえます。
ユーザー数が多くなって、利用者が増えるかどうかで費用対効果を考えて、どこまで詳細に型づけを行うか決めれば良いでしょう。</p>
<p>なお、最初の変数の定義のところで、いくつか型についても紹介しました。それを少し思い出していただければ、と思います。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 型はUnion Typeで複数列挙できる</span>
<span class="kd">let</span> <span class="nx">birthYear</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kt">string</span><span class="p">;</span>

<span class="c1">// 型には文字列や数値の値も設定できる</span>
<span class="kd">let</span> <span class="nx">favoriteFood</span><span class="o">:</span> <span class="s2">&quot;北極&quot;</span> <span class="o">|</span> <span class="s2">&quot;冷やし味噌&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="any">
<h2>一番手抜きな型付け: <code class="docutils literal notranslate"><span class="pre">any</span></code><a class="headerlink" href="#any" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>費用対効果を考えましょう、と言われても、意思決定の幅がわからないと、どこが良いのか決断はできません。
最初に、一番費用が少ない方法を紹介します。
それが <code class="docutils literal notranslate"><span class="pre">any</span></code> です。 <code class="docutils literal notranslate"><span class="pre">any</span></code> と書けば、TypeScriptのコンパイラは、その変数のチェックをすべて放棄します。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">someFunction</span><span class="p">(</span><span class="nx">opts</span>: <span class="kt">any</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">opts</span><span class="p">.</span><span class="nx">debug</span><span class="p">);</span> <span class="c1">// debugがあるかどうかチェックしないのでエラーにならない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これを積極的に使う場面はというと、すでにJavaScriptとして動作していて実績があるコードをTypeScriptにまずは持ってくる、というケースが考えられます。
あとは、メインの引数ではなくて、挙動をコントロールするオプションの項目がかなり複雑で、型定義が複雑な場合などです。
例えば、JSONSchemaを受け取るような引数があったら、JSONSchemaのすべての仕様を満たす型定義を記述するのはかなり時間を要します。
将来やるにしても、まずはコンパイルだけは通したい、というときに使うと良いでしょう。</p>
</div>
<div class="section" id="unknown">
<h2>未知の型: <code class="docutils literal notranslate"><span class="pre">unknown</span></code><a class="headerlink" href="#unknown" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">unknown</span></code> は <code class="docutils literal notranslate"><span class="pre">any</span></code> と似ています。 <code class="docutils literal notranslate"><span class="pre">unknown</span></code> 型の変数にはどのようなデータもチェックなしに入れることができます。
違うのは <code class="docutils literal notranslate"><span class="pre">unknown</span></code> の場合は、その変数を利用する場合には、型アサーションを使ってチェックを行わないとエラーになる点です。
型アサーションについてはこの章の最後で扱います。</p>
<div class="admonition-todo admonition" id="index-0">
<p class="admonition-title">課題</p>
<p>事例をつける</p>
</div>
</div>
<div class="section" id="id2">
<h2>型に名前をつける<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">名前</span> <span class="pre">=</span></code> という構文を使って、型に名前をつけることができます。
名前には、通常の変数や関数名として使える名前が使えます。
ここで定義した型は、変数定義や、関数の引数などで使えます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 型はUnion Typeで複数列挙できる</span>
<span class="nx">type</span> <span class="nx">BirthYear</span> <span class="o">=</span> <span class="kt">number</span> <span class="o">|</span> <span class="kt">string</span><span class="p">;</span>

<span class="c1">// 型には値も設定できる</span>
<span class="nx">type</span> <span class="nx">FoodMenu</span> <span class="o">=</span> <span class="s2">&quot;北極&quot;</span> <span class="o">|</span> <span class="s2">&quot;冷やし味噌&quot;</span><span class="p">;</span>

<span class="c1">// 変数や関数の引数で使える</span>
<span class="kr">const</span> <span class="nx">birthday</span>: <span class="kt">BirthYear</span> <span class="o">=</span> <span class="s2">&quot;平成&quot;</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">orderFood</span><span class="p">(</span><span class="nx">food</span>: <span class="kt">FoodMenu</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使い回しをしないのであれば型名の代わりに、すべての箇所に定義を書いていってもエラーチェックの結果は変わりません。
また、TypeScriptは型名ではなく、型の内容で比較してチェックを行うため、別名の型でも、片方は型で書いて、片方は直接書き下したケースでも問題なくチェックされます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">FoodMenu</span> <span class="o">=</span> <span class="s2">&quot;北極&quot;</span> <span class="o">|</span> <span class="s2">&quot;冷やし味噌&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">myOrder</span>: <span class="kt">FoodMenu</span> <span class="o">=</span> <span class="s2">&quot;北極&quot;</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">orderFood</span><span class="p">(</span><span class="nx">food</span><span class="o">:</span> <span class="s2">&quot;北極&quot;</span> <span class="o">|</span> <span class="s2">&quot;冷やし味噌&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">food</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">orderFood</span><span class="p">(</span><span class="nx">myOrder</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>関数のレスポンスや引数で使うオブジェクトの定義<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> はオブジェクトが持つべき属性の定義にも使えます。
属性には型をつけることができます。
また名前の後ろに <code class="docutils literal notranslate"><span class="pre">?</span></code> をつけることで、省略可能な属性であることを示すことができます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">favoriteBank</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">favoriteGyudon?</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 変数定義時にインタフェースを指定</span>
<span class="kr">const</span> <span class="nx">person</span>: <span class="kt">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Yoichi&quot;</span><span class="p">,</span>
  <span class="nx">favoriteBank</span><span class="o">:</span> <span class="s2">&quot;Mizuho&quot;</span><span class="p">,</span>
  <span class="nx">favoriteGyudon</span><span class="o">:</span> <span class="s2">&quot;Matsuya&quot;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>このように型定義をしておくと、関数の引数などでもエラーチェックが行われ、関数の呼び出し前後での不具合発生を抑えることができます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 関数の引数がPerson型の場合</span>
<span class="nx">registerPerson</span><span class="p">({</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Yoichi&quot;</span><span class="p">,</span>
  <span class="nx">favoriteBank</span><span class="o">:</span> <span class="s2">&quot;Mizuho&quot;</span><span class="p">,</span>
  <span class="nx">favoriteGyudon</span><span class="o">:</span> <span class="s2">&quot;Matsuya&quot;</span>
<span class="p">});</span>

<span class="c1">// レスポンスがPerson型の場合</span>
<span class="kr">const</span> <span class="p">{</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">favoriteBank</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">getPerson</span><span class="p">();</span>
</pre></div>
</div>
<p>もし、必須項目の <code class="docutils literal notranslate"><span class="pre">favoriteBank</span></code> がなければ代入する場所でエラーが発生します。
また、リテラルで書く場合には、不要な項目があってもエラーになります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">person</span>: <span class="kt">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Yoichi&quot;</span>
<span class="p">};</span>
<span class="c1">// error TS2741: Property &#39;favoriteBank&#39; is missing in</span>
<span class="c1">//   type &#39;{ name: string; }&#39; but required in type &#39;Person&#39;.</span>
</pre></div>
</div>
<p>JavaScriptでは、多彩な機能を持つ関数を定義する場合に、オプションとなるパラメータをオブジェクトで渡す、という関数が数多くありました。
ちょっとタイプミスしてしまっただけで期待通りの結果を返さないでしばらく悩む、といったことがよくありました。
TypeScriptで型の定義をすると、このようなトラブルを未然に防ぐことができます。</p>
</div>
<div class="section" id="id4">
<h2>属性名が可変のオブジェクトを扱う<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>これまで説明してきたのは、各キーの名前があらかじめ分かっている、他の言語で言うところの構造体のようなオブジェクトです。
しかし、このオブジェクトは辞書のようにも使われます。
今時であれば <code class="docutils literal notranslate"><span class="pre">Map</span></code> 型を使う方がイテレータなども使えますし、キーの型も自由に選べて良いのですが、例えば、サーバーAPIのレスポンスのJSONなどのようなところでは、どうしてもオブジェクトが登場します。</p>
<p>その時は、 <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">[key:</span> <span class="pre">キーの型]:</span> <span class="pre">値の型}</span></code> と書くことで、辞書のように扱われるオブジェクトの宣言ができます。
なお、 <code class="docutils literal notranslate"><span class="pre">key</span></code> の部分はなんでもよく、 <code class="docutils literal notranslate"><span class="pre">a</span></code> でも <code class="docutils literal notranslate"><span class="pre">b</span></code> でもエラーにはなりませんが、 <code class="docutils literal notranslate"><span class="pre">key</span></code> としておいた方がわかりやすいでしょう。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">postalCodes</span><span class="o">:</span> <span class="p">{</span> <span class="p">[</span><span class="nx">key</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="kt">string</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s2">&quot;602-0000&quot;</span><span class="o">:</span> <span class="s2">&quot;京都市上京区&quot;</span><span class="p">,</span>
  <span class="s2">&quot;602-0827&quot;</span><span class="o">:</span> <span class="s2">&quot;京都市上京区相生町&quot;</span><span class="p">,</span>
  <span class="s2">&quot;602-0828&quot;</span><span class="o">:</span> <span class="s2">&quot;京都市上京区愛染寺町&quot;</span><span class="p">,</span>
  <span class="s2">&quot;602-0054&quot;</span><span class="o">:</span> <span class="s2">&quot;京都市上京区飛鳥井町&quot;</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>なお、キーの型には <code class="docutils literal notranslate"><span class="pre">string</span></code> 以外に <code class="docutils literal notranslate"><span class="pre">number</span></code> なども設定できます。その場合、上記の例だとエラーになりますが、 <code class="docutils literal notranslate"><span class="pre">&quot;6020000&quot;</span></code> （ダブルクオートがある点に注意）とするとエラーがなくなります。
一見数値が入っているように見えますが、JavaScriptのオブジェクトのキーは文字列型ですので、 <code class="docutils literal notranslate"><span class="pre">Object.keys()</span></code> とか <code class="docutils literal notranslate"><span class="pre">Object.entries()</span></code> で取り出すキーの型まで数字になるわけではなく、あくまでも文字列です。
数値としても認識できる文字列を受け取る、という挙動になります。</p>
</div>
<div class="section" id="ab">
<h2>AかつBでなければならない<a class="headerlink" href="#ab" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">|</span> <span class="pre">B</span></code> という記法を紹介しました。これは「AもしくはB」という意味です。
コンピュータの論理式では「AかつB」というのがありますよね？
TypeScriptの型定義ではこれも表現できます。
<code class="docutils literal notranslate"><span class="pre">&amp;</span></code> の記号を使います。</p>
<div class="literal-block-wrapper docutils container" id="id14">
<div class="code-block-caption"><span class="caption-text">型を合成する</span><a class="headerlink" href="#id14" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Twitter</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">twitterId</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">Instagram</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">instagramId</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">shibukawa</span>: <span class="kt">Twitter</span> <span class="o">&amp;</span> <span class="nx">Instagram</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">twitterId</span><span class="o">:</span> <span class="s2">&quot;@shibu_jp&quot;</span><span class="p">,</span>
  <span class="nx">instagramId</span><span class="o">:</span> <span class="s2">&quot;shibukawa&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>この場合、両方のオブジェクトで定義した属性がすべて含まれないと、変数の代入のところでエラーになります。</p>
<p>もちろん、合成した型に名前をつけることもできます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">PartyPeople</span> <span class="o">=</span> <span class="nx">Twitter</span> <span class="o">&amp;</span> <span class="nx">Instagram</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2>パラメータの値によって必要な属性が変わる柔軟な型定義を行う<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>TypeScriptの型は、そのベースとなっているJavaScriptの動的な属性を包括的に扱えるように、かなり柔軟な定義もできるようになっています。
高速な表描画ライブラリのCheetahGrid<a class="footnote-reference brackets" href="#id7" id="id6">1</a>では、カラムの定義をJSONで行うことができます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">grid</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">cheetahGrid</span><span class="p">.</span><span class="nx">ListGrid</span><span class="p">({</span>
  <span class="nx">parentElement</span>: <span class="kt">document.querySelector</span><span class="p">(</span><span class="s1">&#39;#sample2&#39;</span><span class="p">),</span>
  <span class="nx">header</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span><span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span> <span class="nx">caption</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span> <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span>
      <span class="nx">style</span><span class="o">:</span> <span class="p">{</span><span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;red&#39;</span><span class="p">}},</span>
    <span class="p">{</span><span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="nx">caption</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span>
      <span class="nx">style</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">uncheckBgColor</span><span class="o">:</span> <span class="s1">&#39;#FDD&#39;</span><span class="p">,</span>
        <span class="nx">checkBgColor</span><span class="o">:</span> <span class="s1">&#39;rgb(255, 73, 72)&#39;</span>
      <span class="p">}}</span>
  <span class="p">],</span>
<span class="p">});</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">columnType</span></code> の文字によって定義できる <code class="docutils literal notranslate"><span class="pre">style</span></code> の項目が変わります。今は、 <code class="docutils literal notranslate"><span class="pre">number</span></code> と、 <code class="docutils literal notranslate"><span class="pre">check</span></code> がありますね。
<code class="docutils literal notranslate"><span class="pre">check</span></code> の時は <code class="docutils literal notranslate"><span class="pre">uncheckBgColor</span></code> と <code class="docutils literal notranslate"><span class="pre">checkBgColor</span></code> が設定できますが、 <code class="docutils literal notranslate"><span class="pre">number</span></code> はそれらがなく、 <code class="docutils literal notranslate"><span class="pre">color</span></code> があります。
本物のCheetahGridはもっと多くの属性があるのですが、ここでは、このルールだけを設定可能なインタフェースを考えてみます。
簡略化のために属性の省略はないものとします（ただ?をつけるだけですが）。</p>
<p>TypeScriptのインタフェースの定義では「このキーがこの文字列の場合」という指定もできましたね。
次の定義は、チェックボックス用の設定になります。 <code class="docutils literal notranslate"><span class="pre">columnType:</span> <span class="pre">'check'</span></code> という項目があります。</p>
<div class="literal-block-wrapper docutils container" id="id15">
<div class="code-block-caption"><span class="caption-text">チェックボックスのカラム用の設定</span><a class="headerlink" href="#id15" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">CheckStyle</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">uncheckBgColor</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">checkBgColor</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">CheckColumn</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">;</span>
  <span class="nx">caption</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">field</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">style</span>: <span class="kt">CheckStyle</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>数値用のカラムも定義しましょう。</p>
<div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-text">数値用のカラム用の設定</span><a class="headerlink" href="#id16" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">NumberStyle</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">color</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">NumberColumn</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">;</span>
  <span class="nx">caption</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">field</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">style</span>: <span class="kt">NumberStyle</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>上記のカラム定義の配列にはチェックボックスと数値のカラムの両方が来ます。どちらかだけの配列ではなくて、両方を含んでも良い配列を作ります。
その場合は、Union Typeを使って、その配列と定義すれば、両方を入れてもエラーにならない配列が定義できます。
ここでは <code class="docutils literal notranslate"><span class="pre">type</span></code> を使って、Union Typeに名前をつけています。それを配列にしています。</p>
<div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-text">チェックボックス、数値の両方を許容する汎用的な「カラム」型を定義</span><a class="headerlink" href="#id17" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// 両方の型を取り得るUnion Typeを定義</span>
<span class="nx">type</span> <span class="nx">Column</span> <span class="o">=</span> <span class="nx">CheckColumn</span> <span class="o">|</span> <span class="nx">NumberColumn</span><span class="p">;</span>

<span class="c1">// 無事、エラーを出さずに過不足なく型付けできた</span>
<span class="kr">const</span> <span class="nx">header</span>: <span class="kt">Column</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span>
 <span class="p">{</span><span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span> <span class="nx">caption</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span> <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span>
   <span class="nx">style</span><span class="o">:</span> <span class="p">{</span><span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;red&#39;</span><span class="p">}},</span>
 <span class="p">{</span><span class="nx">field</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="nx">caption</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span> <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;check&#39;</span><span class="p">,</span>
   <span class="nx">style</span><span class="o">:</span> <span class="p">{</span>
     <span class="nx">uncheckBgColor</span><span class="o">:</span> <span class="s1">&#39;#FDD&#39;</span><span class="p">,</span>
     <span class="nx">checkBgColor</span><span class="o">:</span> <span class="s1">&#39;rgb(255, 73, 72)&#39;</span>
   <span class="p">}}</span>
<span class="p">];</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>どこまで細かく型をつけるべきか？</p>
<p>これらの機能を駆使すると、かなり細かく型定義が行え、利用者が変な落とし穴に陥いるのを防ぐことができます。</p>
<p>しかし、最初に述べたように、時間は有限です。
型をつける作業は楽しい作業ではありますが、利用者数と見比べて、最初から全部を受け入れるような型を1つだけ作るところから始めても良いでしょう。
実際には次のような短い定義でも十分なことがほとんどです。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Style</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">color?</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">uncheckBgColor?</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">checkBgColor?</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">Column</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">columnType</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span> <span class="o">|</span> <span class="s1">&#39;check&#39;</span><span class="p">;</span>
  <span class="nx">caption</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">field</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">style</span>: <span class="kt">Style</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id6">1</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/future-architect/cheetah-grid">https://github.com/future-architect/cheetah-grid</a></p>
</dd>
</dl>
</div>
<div class="section" id="id8">
<h2>型ガード<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>静的な型付け言語では、どんどん型を厳しく付けていけばすべて幸せになりますよね！というわけにはいかない場面が少しだけあります。</p>
<p>TypeScriptでは、今まで見て来た通り、少し柔軟な型を許容しています。</p>
<ul class="simple">
<li><p>数値型か、あるいは <code class="docutils literal notranslate"><span class="pre">null</span></code></p></li>
<li><p>数字型か、文字列</p></li>
<li><p>オブジェクトの特定の属性 <code class="docutils literal notranslate"><span class="pre">columnType</span></code> が <code class="docutils literal notranslate"><span class="pre">'check'</span></code> という文字列の場合のみ属性が増える</p></li>
</ul>
<p>この複数の型を持つ変数を扱うときに、「2通りの選択肢があるうちの、こっちのパターンの場合のみのロジック」を記述したいときに使うのが型ガードです。</p>
<p>一般的な静的型付け言語でも、ダウンキャストなど、場合によってはプログラマーが意思を入れて型の変換を行わせることがありえます。場合によっては、うまく変換できなかったときに実行時エラーが発生しうる、実行文です。</p>
<p>例えば、Goの場合、HTTP/2の時は <code class="docutils literal notranslate"><span class="pre">http.ResponseWriter</span></code> は <code class="docutils literal notranslate"><span class="pre">http.Pusher</span></code> インタフェースを持っています。これにキャストすることで、サーバープッシュが実現できるというAPI設計になっています。実行時にはランタイムが型を見て変数に値を代入するなどしてくれます。</p>
<div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-text">Goのキャスト</span><a class="headerlink" href="#id18" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">http</span><span class="p">.</span><span class="nx">HandleFunc</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">pusher</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">http</span><span class="p">.</span><span class="nx">Pusher</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="c1">// ↑こちらでキャスト、成功するとbool型のok変数にtrueが入る</span>
        <span class="nx">pusher</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="s">&quot;/application.css&quot;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
<p>しかし、TypeScriptのソースコードはあくまでも、JavaScriptに変換されてから実行されます。型情報などを消すだけでJavaScriptになります。TypeScriptのコンパイラが持つインタフェースや <code class="docutils literal notranslate"><span class="pre">type</span></code> などの固有の型情報は実行時にはランタイムには存在しません。そのため、「このオブジェクトがこのインタフェースを持っているとき」という実行文は他の言語のようにそのまま記述する方法はありません。</p>
<p>TypeScriptがこれを解決する手段として実装しているのが、型ガードという機能です。型情報を全部抜くと単なるJavaScriptとしても有効な文ですが、TypeScriptはこの実行文の文脈を解析し、型の選択肢を適切に絞り込んでいきます。これにより、正しいメソッドが利用されているかどうかを静的解析したりできますし、開発時においても、コード補完も正常に機能します。</p>
<div class="literal-block-wrapper docutils container" id="id19">
<div class="code-block-caption"><span class="caption-text">型ガード</span><a class="headerlink" href="#id19" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="c1">// userNameOrIdは文字列か数値</span>
<span class="kd">let</span> <span class="nx">userNameOrId</span>: <span class="kt">string</span><span class="o">|</span><span class="kt">number</span> <span class="o">=</span> <span class="nx">getUser</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">userNameOrId</span> <span class="o">===</span> <span class="s2">&quot;string&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// このif文の中では、userNameOrIdは文字列型として扱われる</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
        <span class="nx">userName</span>: <span class="kt">userNameOrId.toUpperCase</span><span class="p">()</span>
    <span class="p">});</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// このif文の中では、userNameOrIdは数値型として扱われる</span>
    <span class="kr">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">repository</span><span class="p">.</span><span class="nx">findUserByID</span><span class="p">(</span><span class="nx">userNameOrId</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
        <span class="nx">userName</span>: <span class="kt">user.getName</span><span class="p">()</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>組み込みの型ガード<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コンパイラは、一部のTypeScriptの文を見て、型ガードと判定します。組み込みで使えるのは <code class="docutils literal notranslate"><span class="pre">typeof</span></code> や <code class="docutils literal notranslate"><span class="pre">instanceof</span></code> 、 <code class="docutils literal notranslate"><span class="pre">in</span></code> や比較です。</p>
<p><code class="docutils literal notranslate"><span class="pre">typeof</span> <span class="pre">変数</span></code> は変数の型名を文字列で返します。プリミティブな組込型のいくつかでしか対応できません。</p>
<ul class="simple">
<li><p>undefined: &quot;undefined&quot;</p></li>
<li><p>bool型: &quot;boolean&quot;</p></li>
<li><p>数値: &quot;number&quot;</p></li>
<li><p>文字列: &quot;string&quot;</p></li>
<li><p>シンボル: &quot;symbol&quot;</p></li>
<li><p>関数: &quot;function&quot;</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">null</span></code> は &quot;object&quot;になりますが、それ以外のほとんどが <code class="docutils literal notranslate"><span class="pre">object</span></code> なので区別はつきませんので、 <code class="docutils literal notranslate"><span class="pre">null</span></code> の判定には使えません。</p>
<p><code class="docutils literal notranslate"><span class="pre">変数</span> <span class="pre">instanceof</span> <span class="pre">クラス名</span></code> は自作のクラスなどで使えるものになります。</p>
<p><code class="docutils literal notranslate"><span class="pre">&quot;キー&quot;</span> <span class="pre">in</span> <span class="pre">オブジェクト</span></code> で、オブジェクトに特定の属性が含まれているかどうかの判定ができます。</p>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code> で型付けを行なったオブジェクトの複合型の場合、属性の有無や特定の属性の値がどうなっているかで判断できます。例えば、前述のカラム型の場合、field属性に文字列が入っていて型の判別ができました。これは、その属性値の比較のif文をかけばTypeScriptのコンパイラはきちんと解釈してくれます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Column</span> <span class="o">=</span> <span class="nx">CheckColumn</span> <span class="o">|</span> <span class="nx">NumberColumn</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">getValue</span><span class="p">(</span><span class="nx">column</span>: <span class="kt">Column</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">column</span><span class="p">.</span><span class="nx">field</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ここではcolumnはNumberColumn型</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// ここではcolumnはCheckColumn型</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>ユーザー定義の型ガード<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>TypeScriptのベースになっているJavaScriptでは、長らくオブジェクトが配列かどうかを判定する明確な手法を提供してきませんでした。文字列にして、その結果をパースするとかも行われていました。ECMAScript 5の時代にようやく、 <code class="docutils literal notranslate"><span class="pre">Array.isArray()</span></code> というクラスメソッドが提供されるようになりました。</p>
<p>このようなメソッドは組み込みのタイプガードとしては使えませんが、ユーザー定義の型ガード関数を作成すると、if文の中で特定の型とみなすようにTypeScriptコンパイラに教えることができます。</p>
<p>型ガード関数は、次のような形式で書きます。</p>
<div class="literal-block-wrapper docutils container" id="id20">
<div class="code-block-caption"><span class="caption-text">ユーザー定義の型ガード</span><a class="headerlink" href="#id20" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">arg</span>: <span class="kt">any</span><span class="p">)</span><span class="o">:</span> <span class="nx">arg</span> <span class="nx">is</span> <span class="nb">Array</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<ul class="simple">
<li><p>名前は <code class="docutils literal notranslate"><span class="pre">is型名</span></code> だとわかりやすい</p></li>
<li><p>引数は <code class="docutils literal notranslate"><span class="pre">arg:</span> <span class="pre">any</span></code></p></li>
<li><p>返り値の型は <code class="docutils literal notranslate"><span class="pre">arg</span> <span class="pre">is</span> <span class="pre">Array</span></code></p></li>
<li><p>関数の返り値は、型ガードの条件が満たされる実行文</p></li>
</ul>
<p>なんども説明している通り、型ガードではTypeScriptのコンパイラだけが知っている情報は扱えません。JavaScriptとして実行時にアクセスできる情報（ <code class="docutils literal notranslate"><span class="pre">Array.isArray()</span></code> のような関数、 <code class="docutils literal notranslate"><span class="pre">typeof</span></code> 、 <code class="docutils literal notranslate"><span class="pre">instanceof</span></code> 、 <code class="docutils literal notranslate"><span class="pre">in</span></code> 、比較などあらゆる方法を駆使）を使って、booleanを返す必要があります。</p>
</div>
<div class="section" id="id11">
<h3>型アサーション<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>TypeScriptではキャスト（型アサーション）もいちおうあります（ <code class="docutils literal notranslate"><span class="pre">as</span></code> を後置で置く）が、これは実行文ではなくて、あくまでもコンパイラの持つ型情報を上書きするものです。型ガードとは異なり、実行時には情報を一切参照せずに、ただ変数の型だけが変わります。もちろん、 <code class="docutils literal notranslate"><span class="pre">number</span></code> から <code class="docutils literal notranslate"><span class="pre">string</span></code> へのキャストなどの無理やりのキャストはエラーになりますが、 <code class="docutils literal notranslate"><span class="pre">any</span></code> 型への変換はいつでも可能ですし、 <code class="docutils literal notranslate"><span class="pre">any</span></code> から他の型への変換も自由にできます。一旦 <code class="docutils literal notranslate"><span class="pre">any</span></code> を挟むとコンパイラを騙してどんな型にも変換できてしまいますが、コンパイルエラーは抑制できますが、実行時エラーになるだけなので、乱用しないようにしましょう。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">page</span>: <span class="kt">any</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;profile page&quot;</span> <span class="p">};</span>
<span class="c1">// any型からはasでどんな型にも変換できる</span>
<span class="kr">const</span> <span class="nx">name</span>: <span class="kt">string</span> <span class="o">=</span> <span class="nx">page</span> <span class="kr">as</span> <span class="kt">string</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="keyof-mapped-type">
<h2><code class="docutils literal notranslate"><span class="pre">keyof</span></code> とMapped Type: オブジェクトのキーの文字列のみを許容する動的な型宣言<a class="headerlink" href="#keyof-mapped-type" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この項目は中級者向けの項目になります。一般的にはジェネリクスと一緒に使うことが多い機能です。</p>
<p>JavaScriptは動的なオブジェクトを駆使してプログラミングをしてきました。そのオブジェクトが他の言語でいう構造体、あるいはレコード型のように特定の属性を持つことが分かっている用途でのみ使われるのであれば今まで説明してきた機能だけで十分に利用できます。</p>
<p>一方、 <code class="docutils literal notranslate"><span class="pre">Map</span></code> のように、何かしらの識別子をキーにして子供として要素を持つデータ構造として使われているケースなどもあります。例えばフォームのIDとその値をオブジェクトとして表現する場合は、フォームごとに項目が変わります。
そのような用途では、「このキーがある」「このキーのみを対象としたい」「このキーの型情報」みたいな型宣言がしたくなります。 <code class="docutils literal notranslate"><span class="pre">keyof</span></code> を使うとこのようなケースでの柔軟性があがります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">Park</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">hasTako</span>: <span class="kt">boolean</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Parkのキーである、 &quot;name&quot; | &quot;hasTako&quot;が割り当てられる</span>
<span class="nx">type</span> <span class="nx">Key</span> <span class="o">=</span> <span class="nx">keyof</span> <span class="nx">Park</span><span class="p">;</span>
<span class="c1">// 指定されたキー以外はエラーになる</span>
<span class="kr">const</span> <span class="nx">key</span>: <span class="kt">Key</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span><span class="p">;</span>
<span class="c1">// 1行でも書ける</span>
<span class="kr">const</span> <span class="nx">key</span>: <span class="kt">keyof</span> <span class="nx">Park</span> <span class="o">=</span> <span class="s2">&quot;hasTako&quot;</span><span class="p">;</span>

<span class="c1">// 値の方の型も取れる(stringになる)</span>
<span class="nx">type</span> <span class="nx">ParkName</span> <span class="o">=</span> <span class="nx">Park</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">];</span>

<span class="c1">// 指定されたキー以外はエラーになる</span>
<span class="kr">const</span> <span class="nx">key</span>: <span class="kt">keyof</span> <span class="nx">Park</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>また、オブジェクトのキー全部に対して型定義をすることもできます。構造としては次のように書きます。
オブジェクトのキーは <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">]</span></code> でくくることで式を書くことができました。それの文法と似た書き方になっています。
Kというのがキー名の変数で、 <code class="docutils literal notranslate"><span class="pre">in</span></code> によるループの要素が1つずつ入るイメージです。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span>// 基本の書き方
{[K in keyof Object]: プロパティの型}

// 入力のObjectとキーは同じだがバリデーション結果を返す（値はすべてboolean）
{readonly [K in keyof Object]: boolean}

// 入力のObjectとまったく同じものをこの記法で書いたもの
{[K in keyof Object]: Object[K]}

// 入力のObjectとまったく同じだが読み込み専用
{readonly [K in keyof Object]: Object[K]}
</pre></div>
</div>
<p>なお、 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> を付与するのはジェネリクスなユーティリティ型 <code class="docutils literal notranslate"><span class="pre">Readonly&lt;T&gt;</span></code> というものがあるので実際にこのコードを書くことはないでしょう。</p>
<p>以下のコードが読み込み専用の型定義になります。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="nx">type</span> <span class="nx">ParkForm</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">hasTako</span>: <span class="kt">boolean</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 値を全て読み込み専用にした型</span>
<span class="nx">type</span> <span class="nx">FrozenParkForm</span> <span class="o">=</span> <span class="p">{</span><span class="nx">readonly</span> <span class="p">[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">keyof</span> <span class="nx">ParkForm</span><span class="p">]</span><span class="o">:</span> <span class="nx">ParkForm</span><span class="p">[</span><span class="nx">K</span><span class="p">]};</span>

<span class="kr">const</span> <span class="nx">form</span>: <span class="kt">FrozenParkForm</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;恵比寿東&quot;</span><span class="p">,</span>
  <span class="nx">hasTako</span>: <span class="kt">true</span>
<span class="p">};</span>

<span class="c1">// 読み込み専用なのでエラーになる</span>
<span class="nx">form</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;和布刈公園&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h2>インタフェースを使った型定義<a class="headerlink" href="#id12" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>オブジェクトの型をつける方法には、 <code class="docutils literal notranslate"><span class="pre">type</span></code> を使う方法以外に、インタフェース定義を使った方法もあります。
インタフェースは基本的には、Java同様に他の章で紹介するクラスのための機能ですが、
ほぼ同じことができますし、世間のコードではこちらの方もよく見かけます。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">favoriteBank</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">favoriteGyudon?</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>前述の型を合成する方法についても、二つのインタフェースの継承でも表現できますが、あまり見かけたことはありません。</p>
<div class="highlight-ts notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">PartyPeople</span> <span class="kr">extends</span> <span class="nx">Twitter</span><span class="p">,</span> <span class="nx">Instagram</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">shibukawa</span>: <span class="kt">PartyPeople</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">twitterId</span><span class="o">:</span> <span class="s2">&quot;@shibu_jp&quot;</span><span class="p">,</span>
  <span class="nx">instagramId</span><span class="o">:</span> <span class="s2">&quot;shibukawa&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h2>まとめ<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>基本的な型付けの作法、とくにオブジェクトに対する型付けを学びました。
JavaScriptの世界では、プログラムのロジック以上に、柔軟なデータ構造を活用したコーディングが他の言語以上に行われていました。
そのため、ここで紹介した機能は、そのJavaScriptの世界に型を設定していくうえで必要性の高い知識となります。</p>
<p>また、型を実行時にあつかう方法</p>
<p>これから紹介するクラスの場合は、実装時に自然と型定義もできあがりますが、TypeScriptではクラスに頼らない関数型スタイルのコーディングも増えています。
このオブジェクトの型付けは関数の入出力でも力を発揮するため、身につけておいて損はないでしょう。</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">基本的な型付け</a><ul>
<li><a class="reference internal" href="#any">一番手抜きな型付け: <code class="docutils literal notranslate"><span class="pre">any</span></code></a></li>
<li><a class="reference internal" href="#unknown">未知の型: <code class="docutils literal notranslate"><span class="pre">unknown</span></code></a></li>
<li><a class="reference internal" href="#id2">型に名前をつける</a></li>
<li><a class="reference internal" href="#id3">関数のレスポンスや引数で使うオブジェクトの定義</a></li>
<li><a class="reference internal" href="#id4">属性名が可変のオブジェクトを扱う</a></li>
<li><a class="reference internal" href="#ab">AかつBでなければならない</a></li>
<li><a class="reference internal" href="#id5">パラメータの値によって必要な属性が変わる柔軟な型定義を行う</a></li>
<li><a class="reference internal" href="#id8">型ガード</a><ul>
<li><a class="reference internal" href="#id9">組み込みの型ガード</a></li>
<li><a class="reference internal" href="#id10">ユーザー定義の型ガード</a></li>
<li><a class="reference internal" href="#id11">型アサーション</a></li>
</ul>
</li>
<li><a class="reference internal" href="#keyof-mapped-type"><code class="docutils literal notranslate"><span class="pre">keyof</span></code> とMapped Type: オブジェクトのキーの文字列のみを許容する動的な型宣言</a></li>
<li><a class="reference internal" href="#id12">インタフェースを使った型定義</a></li>
<li><a class="reference internal" href="#id13">まとめ</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="syntax.html" title="前の章へ">基本的な構文</a></li>
      <li>Next: <a href="function.html" title="次の章へ">関数</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/typing.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div><div>
    <h4>Page Info</h4>
    <p>
    <ul>
        <li>英数記号: 5563</li>
        <li>非アスキー: 6189</li>
        <li>合計文字数: 11752</li>
        <li>半角換算: 17941</li>
        <li>全角換算: 8970.5</li>
    </ul>
    </p>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Future Corporation.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.0.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/typing.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>